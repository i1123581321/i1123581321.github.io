---
layout: post
title: "调度场算法与逆波兰表达式的求解"
description: "重要的调度场算法"
categories: [笔记]
tags: [计算机,算法]
redirect_from:
  -/2018/06/03/
---

调度场算法（Shunting Yard Algorithm）[^1]是一个用于将中缀表达式转换为后缀表达式的经典算法，由 Edsger Wybe Dijkstra 引入，因其操作类似于火车编组场而得名。调度场算法在解决计算机程序解析处理中缀表达式的工作中起着重要的作用。而若想理解这个算法，首先就要对前缀，中缀，后缀表达式的概念有基本的了解。

* Kramdown table of contents
{:toc .toc}

# 前缀、中缀、后缀表达式

前缀、中缀、后缀都是对表达式的记法，区别在于操作符相对于操作数的位置有所不同，前缀表达式的操作符位于操作数的前面，中缀、后缀同理。举个最简单的例子：

5*(3+4)

* 前缀表达法：* 5 + 3 4
* 中缀表达法：5 * (3 + 4)
* 后缀表达法：5 3 4 + *

## 人类的习惯——中缀表达式

对于一般人，在生活中接触到最多的就是中缀表达式了，绝大多数数学表达式都是采用的中缀表示法。中缀表示法[^2]（或中缀记法）是一个通用的算术或逻辑公式表示方法，操作符是以中缀形式处于操作数的中间。 **括号** 用于表示运算的优先级，这是中缀表示法独有的特性（前缀、后缀表示法不需要括号也能使表达式无歧义）。中缀表示法虽然对于人来说很容易理解，但是却难以被电脑解析：

* 对人来说可以很轻松的确定算式中不同操作符的优先级以及括号的嵌套关系，并以正确的顺序计算，但对于顺序读入表达式的计算机程序而言，这一过程需要重复扫描表达式多次，以确定运算顺序和括号嵌套关系。
* 每脱去一层括号，计算机也要扫描整个式子一遍以确定还有没有剩余的括号。
* 难以判断表达式合法性（括号配对）

这些原因导致处理中缀表达式的算法复杂度非常高，计算机的效率大大降低。于是便需要另外一种表达方式——它与中缀表达法的表达式等价，但更易于计算机处理——波兰表达法。

## 波兰与逆波兰表示法

### 波兰表示法（前缀表示法）

波兰表示法[^3]（Polish notation，或波兰记法），是一种逻辑、算术和代数表示方法，其特点是操作符置于操作数的前面，因此也称做前缀表示法。如果操作符的 **元数** （arity）是固定的，则语法上不需要括号仍然能被无歧义地解析。波兰记法是波兰数学家扬 · 武卡谢维奇 1920 年代引入的，用于简化命题逻辑。

简单算术的前缀表达式主要是用于学术研究方面。在计算机编程方面，LISP 的 S - 表达式中广泛地使用了前缀记法，S - 表达式中使用了括号是因为它的算术操作符有可变的元数（arity）。

前缀表达式的运算顺序很容易检测。需注意的是，当运算时，操作符是作用在第一个操作数上，特别是 **需注意不满足交换律的运算** ，如除法、减法。例如: "/ 10 5 = 2" 表示 10/5 ，结果是 2，而不是 1/2

### 逆波兰表示法（后缀表示法）

逆波兰表示法[^4]（Reverse Polish notation，RPN，或逆波兰记法），是一种是由波兰数学家扬 · 武卡谢维奇 1920 年引入的数学表达式方式，在逆波兰记法中，所有操作符置于操作数的后面，因此也被称为后缀表示法。逆波兰记法不需要括号来标识操作符的优先级。

逆波兰结构由弗里德里希 · 鲍尔（Friedrich L. Bauer）和艾兹格 · 迪科斯彻在 1960 年代早期提议用于表达式求值，以利用堆栈结构减少计算机内存访问。逆波兰记法和相应的算法由澳大利亚哲学家、计算机学家查尔斯 · 汉布林（Charles Hamblin）在 1960 年代中期扩充。

在 1960 和 1970 年代，逆波兰记法广泛地被用于台式计算器，因此也在普通公众（工程、商业和金融领域）中使用。

注意：**逆波兰记法并不是简单的波兰表达式的反转** 。因为对于不满足交换律的操作符，它的操作数写法仍然是常规顺序，如，波兰记法 "/ 6 3" 的逆波兰记法是 "6 3 /" 而不是"3 6 /", 数字的数位写法也是常规顺序。

# 调度场算法

接下来就是重头戏了，中缀表达式易于人类理解，后缀表达式便于程序计算，于是一个能将中缀表达式转换为后缀表达式的算法——调度场算法——就是连接人与程序的关键了。在实际中，一般将表达式化为抽象语法树，而后缀表示法就对应树的后序遍历（前缀表示法对应前序遍历，中缀表示法对应中序遍历，在此略过不表）

## 算法简例

以下是使用调度场算法的一个简例：

输入 3 + 4

1. 将 3 输入输出队列 (每当输入一个数字时，直接进入输出队列)
2. 将 + 号压入运算堆栈
3. 将 4 输入输出队列
4. 输入结束，将操作符堆栈中剩余操作符入输出队列
5. 输出 3 4 +

可以看出调度场算法的两条简单的规则：

* 当读入一个数字时直接入输出队列
* 当输入结束后，运算符队列中所有操作符入输出队列

## 详细思想

* 当还有记号可以读取时：
  * 读取一个记号。
  * 如果这个记号表示一个数字，那么将其添加到输出队列中。
  * 如果这个记号表示一个函数，那么将其压入栈当中。
  * 如果这个记号表示一个函数参数的分隔符（例如，一个半角逗号 , ）：
    * 从栈当中不断地弹出操作符并且放入输出队列中去，直到栈顶部的元素为一个左括号为止。如果一直没有遇到左括号，那么要么是分隔符放错了位置，要么是括号不匹配。
  * 如果这个记号表示一个操作符，记做 O1，那么：
    * 只要存在另一个记为 O2 的操作符位于栈的顶端，并且
      * 如果 **O1 是左结合性的并且它的运算符优先级要小于或者等于 O2 的优先级**，或者如果 **O1 是右结合性的并且它的运算符优先级比 O2 的要低**，那么
        * 将 O2 从栈的顶端弹出并且放入输出队列中（循环直至以上条件不满足为止）；
    * 然后，将 O1 压入栈的顶端。
  * 如果这个记号是一个左括号，那么就将其压入栈当中。
  * 如果这个记号是一个右括号，那么：
    * 从栈当中不断地弹出操作符并且放入输出队列中，直到栈顶部的元素为左括号为止。
    * **将左括号从栈的顶端弹出，但并不放入输出队列中去**。
    * 如果此时位于栈顶端的记号表示一个函数，那么将其弹出并放入输出队列中去。
    * 如果在找到一个左括号之前栈就已经弹出了所有元素，那么就表示在表达式中存在不匹配的括号。
* 当再没有记号可以读取时：
  * 如果此时在栈当中还有操作符：
    * 如果此时位于栈顶端的操作符是一个括号，那么就表示在表达式中存在不匹配的括号。
    * 将操作符逐个弹出并放入输出队列中。

* 退出算法。

## 例子

3 + 4 * 2 / (1 - 5) ^ 2 ^ 3

|输入|动作|输出（逆波兰）|运算符栈|备注|
|:-:| :-| :-|-: |:-|
|3|符号加入输出队列|3|||
|+|符号压入操作符栈|3|+||
|4|符号加入输出队列|3 4 |+||
|*|符号压入操作符栈|3 4 |* +|* 优先级高于 +|
|2|符号加入输出队列|3 4 2|* +||
|/|弹出栈中元素，将符号压入操作符栈|3 4 2 *|/ +|/ 优先级与 * 相同， 高于 +|
|(|符号压入操作符栈|3 4 2 *|( / +||
|1|符号加入输出队列|3 4 2 * 1|( / +||
|-|符号压入操作符栈|3 4 2 * 1|- ( / + ||
|5|符号加入输出队列|3 4 2 * 1 5|- ( / + ||
|)|弹出栈中元素直到循环到 (，弹出(|3 4 2 * 1 5 - | / + |循环到找到 ( ，结束括号匹配|
|^|符号压入操作符栈|3 4 2 * 1 5 - |^ / +|^ 优先级高于 /|
|2|符号加入输出队列|3 4 2 * 1 5 - 2|^ / +||
|^|符号压入操作符栈|3 4 2 * 1 5 - 2|^ ^ / +|^ 为右至左求值|
|3|符号加入输出队列|3 4 2 * 1 5 - 2 3|^ ^ / +||
|END|栈中元素弹出，加入输出队列|3 4 2 * 1 5 - 2 3 ^ ^ / +|||

# 逆波兰表示法的求值——栈

此时距离想要解决的问题已经很接近了，那就是让计算机求解表达式的值。在将中缀表达式转换为后缀表达式后，由于逆波兰表达法的特性，可以利用栈 LIFO 的特点，从左向右顺序求值。

求解逆波兰表达式的基本思想是：顺序读入逆波兰表达式，遇到数字则压入栈，遇到操作符则从栈弹出对应数量的操作数，运算后的结果再压入栈，最终栈中只剩下一个数字，便是操作的结果。

## 逆波兰求值简例

中缀表达式 5 + ((1 + 2) * 4) − 3 写作

5 1 2 + 4 * + 3 −

下表给出了该逆波兰表达式从左至右求值的过程，堆栈栏给出了中间值，用于跟踪算法。

|输入|操作|堆栈|备注|
|:-:|:-|:-|:-|
|5|入栈|5||
|1|入栈|1 5||
|2|入栈|2 1 5||
|+|加法运算|3 5|1，2 出栈，结果 3 入栈|
|4|入栈|4 3 5||
|*|乘法运算|12 5|3，4 出栈，结果 12 入栈|
|+|加法运算|17|5，12 出栈，结果 17 入栈|
|3|入栈|3 17||
|-|减法运算|14|17，3 出栈，结果 14 入栈|
|END|结束|14|最终栈中结果就是表达式的值|

## 核心思想

* 当输入队列不为空
  * 读入下一个符号 X
  * 如果 X 是操作数
    * 入栈
  * 否则如果 X 是操作符
    * 一个先验的表给出该操作符所需的参数数量 n
    * 如果 栈中元素少于 n
      * 错误，操作数不足
    * 否则，n 个操作数出栈
    * 进行计算
    * 计算所得值入栈
* 如果 栈中只有一个值
  * 这个值就是计算结果
* 否则
  * 用户输入了多余的操作数

## 逆波兰表示法的意义

在实际的运算过程中，采用逆波兰表示法是十分有意义的

* 当有操作符时就计算，因此，表达式并不是从右至左整体计算而是每次由中心向外计算一部分，这样在复杂运算中就很少导致操作符错误。
* 堆栈自动记录中间结果，这就是为什么逆波兰计算器能容易对任意复杂的表达式求值。与普通科学计算器不同，它对表达式的复杂性没有限制。
* 逆波兰表达式中不需要括号，用户只需按照表达式顺序求值，让堆栈自动记录中间结果；同样的，也不需要指定操作符的优先级。
* 逆波兰计算器中，没有 “等号” 键用于开始计算。
* 逆波兰计算器需要 “确认” 键用于区分两个相邻的操作数。
* 机器状态永远是一个堆栈状态，堆栈里是需要运算的操作数，栈内不会有操作符。

## 波兰表示法的求值

波兰表达式的求值与逆波兰表达式的求值十分相似，均是使用栈，唯一的区别在于求解波兰表达式时读入顺序是从右向左。

[^1]:[调度场算法 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95)
[^2]:[中缀表示法 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E4%B8%AD%E7%BC%80%E8%A1%A8%E7%A4%BA%E6%B3%95)
[^3]:[波兰表示法 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95)
[^4]:[逆波兰表示法 - 维基百科，自由的百科全书](https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95)