---
layout: post
title: "图的遍历——深度优先搜索与广度优先搜索"
description: "关于深度优先搜索和广度优先搜索的一点理解"
categories: [笔记]
tags: [计算机,算法]
redirect_from:
  -/2018/05/15/
---

图的遍历：是指从图的某一个顶点出发，按某种方法沿图的边对图中所有顶点访问且仅访问一次（树是特殊的图），图的遍历主要有两种方法：深度优先搜索（Depth-First-Search）和广度优先搜索（Breadth-First-Search）。

* Kramdown table of contents
{:toc .toc}

# 深度优先搜索（DFS）

深度优先搜索[^1]算法（英语：Depth-First-Search，简称 DFS）是一种用于遍历或搜索树或图的算法。沿着树的**深度**遍历树的节点，尽可能深的搜索树的分支。当节点 v 的所在边都己被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。

## DFS的优点

* 内存开销较小，每次只需维护一个结点
* 能处理子节点较多或树层次过深的情况（相比BFS）
* 一般用于解决连通性问题（是否有解）

## DFS的缺点

* 只能寻找有解但无法找到最优解（寻找最优解要遍历所有路径）

## DFS实现

1. 将根结点放入容器
2. 从容器中取出第一个结点，检验是否满足目标
    * 如果满足目标，则结束搜索，返回结果
    * 如果不满足目标，则将它的某一个未检验过的子节点加入容器
3. 重复 2
4. 如果不存在未检测的直接子节点
    * 将上一级结点加入容器
    * 重复步骤 2
5. 重复步骤 4
6. 若容器为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传 “找不到目标”。

遍历搜索图的时候，为了防止同一结点被多次访问，需要使用一个访问标记数组 `visited[]` 来标记顶点是否已经被访问过。实现可采用堆栈的结构，将要检查的结点压入栈，如果到达终点（即不可继续访问）则可将其弹出栈，再次压入栈顶结点的另一个子节点进行搜索。

伪代码（递归）：

{% highlight c++ linenos=table %}
void DFS()
{
    if()//到达终点
    {
        return;
    }
    for(i = 0;i < n;++i)//所有节点
    {
        if()//可向下走
        {
            DFS();//向下走
        }
    }
}
{% endhighlight %}

C++代码（非递归实现）：

{% highlight c++ linenos=table %}
/*
 * @Author: Qian 
 * @Date: 2018-05-14 20:04:22 
 * @Last Modified by: Qian
 * @Last Modified time: 2018-05-15 00:11:29
 */
#include <iostream>
#include <stack>
#define NODE_NUM 90 //结点数量

struct Node
{
    int content;
    Node *childs[3];
};

bool visited[NODE_NUM];//记录是否访问过的数组

int main(void)
{
    Node tree[NODE_NUM];
    int i = 0;
    bool flag;

    while (i < NODE_NUM)//生成树
    {
        tree[i].content = i;
        int child = i * 3 + 1;

        for (int j = 0; j < 3; j++)
        {
            if (child + j < 90)
            {
                tree[i].childs[j] = &tree[child + j];
            }
            else
            {
                tree[i].childs[j] = NULL;
            }
        }
        i++;
    }

    //DFS
    std::stack<Node *> visit;

    visit.push(&tree[0]); //将根节点放入栈

    while (!visit.empty()) //当栈不为空
    {
        Node *current = visit.top(); //获取当前栈中第一个元素
        if (!visited[current->content]) //如果没有访问过
        {
            std::cout << current->content << std::endl; //输出内容
            visited[current->content] = true; //标记为访问过
        }
        flag = false;
        for (i = 0; i < 3; i++)
        {
        if (current->childs[i] != NULL && !visited[current->childs[i]->content]) 
            {
                visit.push(current->childs[i]); //子节点压入栈
                flag = true;
                break;
            }
        }
        if (!flag)
        {
            visit.pop(); //如果没有子节点或子节点均已访问过，结点退栈
        }
    }
    return 0;
}
{% endhighlight %}

# 广度优先搜索（BFS）

广度优先搜索[^2]算法（英语：Breadth-First-Search，缩写为 BFS）是一种图搜索算法。BFS 是从根节点开始，沿着树的**宽度**遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用 open-closed 表。属于盲目搜索。

从算法的观点，所有因为展开节点而得到的子节点都会被加进一个先进先出的队列中。一般的实现里，其邻居节点尚未被检验过的节点会被放置在一个被称为 open 的容器中（例如队列或是链表），而被检验过的节点则被放置在被称为 closed 的容器中。

## BFS的优点

* 能够找出最优解（非加权情况），很多求最短路径的算法是基于广度优先搜索的

## BFS的缺点

* 在树的结点较多或层次较深时空间开销较大（因为优先展开结点，内存消耗比 DFS 大得多）
* 必须遍历所有分支

## BFS实现

1. 将根节点放入队列
2. 从队列中取出第一个结点，检验是否为目标
    * 如果找到目标，结束搜索，回传结果
    * 否则将其所有未检查的子节点加入队列
3. 若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传 “找不到目标”。
4. 重复步骤 2

与 DFS 相同，使用 BFS 遍历搜索图的时候，为了防止同一结点被多次访问，需要使用一个访问标记数组 `visited[]` 来标记顶点是否已经被访问过（数组或在结点较多时 HASH 实现）。可用队列实现 BFS ，对于每个从队列首取出的结点，访问后将其子节点从队列尾加入队列。

伪代码：

{% highlight python linenos=table %}
def BFS:
    queue.push(root)                    #根节点加入队列
    # do something with root
    while not queue.empty():            #当队列非空时
        current = queue.pop()           #取出队列中第一个元素
        # do something with current
        for child in current.childs :
            queue.push(child)           #将所有子节点加入队列
{% endhighlight %}

C++代码（非递归实现）：

{% highlight c++ linenos=table %}
/*
 * @Author: Qian 
 * @Date: 2018-05-14 23:42:10 
 * @Last Modified by:   Qian 
 * @Last Modified time: 2018-05-14 23:42:10 
 */

#include <iostream>
#include <queue>
#define NODE_NUM 90 //结点数量

struct Node
{
    int content;
    Node *childs[3];
};

int main(void)
{
    Node tree[NODE_NUM];
    int i = 0;
    //bool flag;

    while (i < NODE_NUM) //生成树
    {
        tree[i].content = i;
        int child = i * 3 + 1;

        for (int j = 0; j < 3; j++)
        {
            if (child + j < 90)
            {
                tree[i].childs[j] = &tree[child + j];
            }
            else
            {
                tree[i].childs[j] = NULL;
            }
        }
        i++;
    }

    //BFS
    std::queue<Node* > visit;

    visit.push (&tree[0]); //将根节点加入队列
    while (!visit.empty ())
    {
        Node* current = visit.front (); //取出队列中第一个结点
        visit.pop ();
        std::cout << current->content << std::endl;
        for (i = 0; i < 3; i++)
        {
            if (current->childs[i] != NULL)
            {
                visit.push(current->childs[i]); //将其所有子节点加入队列
            }
        }
    }
    return 0;
}
{% endhighlight %}

# 《算法导论》中的 DFS 与 BFS

在《算法导论》[^3]中对广度优先算法和深度优先算法给出了更详细的解释，书中采用了白、灰、黑三种颜色标记结点的访问情况，在加入额外的程序语句的时候还可以利用 DFS 对图进行拓扑排序，在此就不多展开了.

[^1]:[深度优先算法 - 维基百科，自由的百科全书]("https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2")
[^2]:[广度优先算法 - 维基百科，自由的百科全书]("https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2")
[^3]:[算法导论（原书第 3 版） (豆瓣)]("https://book.douban.com/subject/20432061/")